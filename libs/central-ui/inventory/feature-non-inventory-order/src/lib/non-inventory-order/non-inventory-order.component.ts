import { TypedFormGroupSelectionModel } from '@vioc-angular/shared/common-functionality';
import { Component, OnDestroy, OnInit, ViewChild } from '@angular/core';
import { FormArray } from '@angular/forms';
import { MatSort } from '@angular/material/sort';
import { MatTable, MatTableDataSource } from '@angular/material/table';
import { ActivatedRoute, ParamMap, Router } from '@angular/router';
import { ParameterFacade } from '@vioc-angular/central-ui/config/data-access-parameter';
import { NonInventoryItemFacade } from '@vioc-angular/central-ui/inventory/data-access-non-inventory-item';
import {
    NonInventoryCatalog,
    NonInventoryOrder,
    NonInventoryOrderFacade,
    NonInventoryOrderItem,
    NonInventoryOrderPK,
} from '@vioc-angular/central-ui/inventory/data-access-non-inventory-order';
import { ResourceFacade } from '@vioc-angular/central-ui/organization/data-access-resources';
import { SaveFacade } from '@vioc-angular/central-ui/util-component';
import { RouterService } from '@vioc-angular/central-ui/util-router';
import { AccessMode } from '@vioc-angular/security/util-authorization';
import { QuerySearch, SearchLine } from '@vioc-angular/shared/common-api-models';
import { Described, isNullOrUndefined } from '@vioc-angular/shared/common-functionality';
import { MessageFacade } from '@vioc-angular/shared/data-access-message';
import { DialogComponent } from '@vioc-angular/shared/ui-dialog';
import { ResponseEntity } from '@vioc-angular/shared/util-api';
import { Column, Comparators } from '@vioc-angular/shared/util-column';
import { DataModifyingComponent } from '@vioc-angular/shared/util-data-modifying';
import { FormFactory, TypedFormGroup } from '@vioc-angular/shared/util-form';
import { Observable, ReplaySubject, throwError } from 'rxjs';
import { catchError, debounceTime, map, takeUntil, tap } from 'rxjs/operators';
import { NonInventoryOrderForms } from '../non-inventory-order-module-forms';

@Component({
    selector: 'vioc-angular-non-inventory-order',
    templateUrl: './non-inventory-order.component.html',
    styleUrls: ['./non-inventory-order.component.scss'],
    providers: [NonInventoryOrderFacade, ResourceFacade, ParameterFacade, NonInventoryItemFacade],
})
export class NonInventoryOrderComponent extends DataModifyingComponent implements OnInit, OnDestroy {
    @ViewChild(MatSort, { static: false }) set sort(sort: MatSort) {
        this.items.sort = sort;
    }

    @ViewChild(MatTable, { static: false }) table: MatTable<NonInventoryOrderItem>;

    /** Dialog used to confirm if user wishes to finalize order */
    @ViewChild('finalizeOrderDialog', { static: true }) finalizeDialog: DialogComponent;

    /** Mode that determines state of the page */
    accessMode: AccessMode;

    /** Model that holds values of the Order being viewed */
    model: NonInventoryOrder;

    /** Form that handles validating and updating order fields */
    form: TypedFormGroup<NonInventoryOrder>;

    /** List of all stores the user has access to */
    storeList: any[];

    /** SelectionModel for the currently selected data in the table. We need to use custom comparator for comparing different instances of the forms */
    selection = new TypedFormGroupSelectionModel<NonInventoryOrderItem>(true, false, 'nonInventoryCatalog');

    /** Status that determines if the page is loading. Used to disable page elements when loading. */
    isLoading = false;

    /** Status that determines if the page is generating an non inventory order. */
    isGeneratingOrder = false;

    /** Indicates that an order is being auto generated by passing the store and vendor as query params */
    isAutoGenerating = false;

    /** Indicates that the non inventory order is old and should not attempt to load the page until an action has been take for the old order. */
    isOldOrder = false;

    items = new MatTableDataSource<TypedFormGroup<NonInventoryOrderItem>>([]);

    describedEquals = Described.idEquals;
    vendorDisplayFn = Described.descriptionMapper;
    storeDisplayFn = Described.codeAndDescriptionMapper;

    inventoryOrderErrorMapping = NonInventoryOrderForms.inventoryOrderErrorMapping;

    saveFacade: SaveFacade<NonInventoryOrder>;

    finalizeFacade: SaveFacade<NonInventoryOrder>;

    queryParams: ParamMap;

    querySearch: QuerySearch;

    company: Described;

    storeCode: string;

    private readonly _destroyed = new ReplaySubject(1);

    // Product table config
    displayedColumns = [
        'select',
        'nonInventoryCatalog.number',
        'nonInventoryCatalog.description',
        'uom',
        'nonInventoryCatalog.minimumQuantity',
        'nonInventoryCatalog.maximumQuantity',
        'nonInventoryCatalog.quantityPerPack',
        'quantity',
    ];

    constructor(
        private readonly router: Router,
        private readonly route: ActivatedRoute,
        private readonly formFactory: FormFactory,
        private readonly routerService: RouterService,
        private readonly resourceFacade: ResourceFacade,
        readonly nonInventoryOrderFacade: NonInventoryOrderFacade,
        readonly nonInventoryItemFacade: NonInventoryItemFacade,
        readonly messageFacade: MessageFacade
    ) {
        super();
        this.saveFacade = new SaveFacade(
            this.routerService,
            messageFacade,
            (model) => this.nonInventoryOrderFacade.save(model),
            (io) => `Non Inventory Order ${io.id ? io.id.orderNumber + ' ' : ''}saved successfully`,
            (isLoading: boolean) => (this.isLoading = isLoading),
            (form: TypedFormGroup<NonInventoryOrder>, model: NonInventoryOrder): NonInventoryOrder => {
                return Object.assign({ ...model }, form.value);
            }
        );
        this.finalizeFacade = new SaveFacade(
            this.routerService,
            messageFacade,
            (model) => this.nonInventoryOrderFacade.finalize(model),
            (io) => `Non Inventory Order ${io.id ? io.id.orderNumber + ' ' : ''}finalized successfully`,
            (isLoading: boolean) => (this.isLoading = isLoading),
            (form: TypedFormGroup<NonInventoryOrder>, model: NonInventoryOrder): NonInventoryOrder => {
                return Object.assign({ ...model }, form.value);
            }
        );
    }

    ngOnInit(): void {
        // Parse parameters from URL for view
        const params = this.getRouteParams(this.route);
        this.accessMode = params.accessMode;
        const storeCode = params.storeCode;
        const orderNumber = params.orderNumber;
        if (this.accessMode.isView || this.accessMode.isEdit) {
            this.nonInventoryOrderFacade
                .findNonInventoryOrder(storeCode, orderNumber)
                .subscribe((nonInventoryOrder) => {
                    this.model = nonInventoryOrder;
                    this.initializeForm(this.model);
                    this.initializeTable();
                });
        } else if (this.accessMode.isAdd) {
            this.model = new NonInventoryOrder();
            this.initializeForm(this.model);
        } else {
            throw Error('Unhandled Access Mode: ' + this.accessMode?.urlSegement);
        }
    }

    /** Function that supplies a query to the `NonInventoryItemAddInputComponent` to searching for item to add to the non inventory order. */
    readonly searchItemsFn = (querySearch: QuerySearch): Observable<ResponseEntity<NonInventoryCatalog>> => {
        const activeRestriction = new SearchLine(
            Column.of({ apiFieldPath: 'active', name: 'active', type: 'boolean' }),
            Comparators.true
        ).toQueryRestriction();
        const companyRestriction = new SearchLine(
            Column.of({ apiFieldPath: 'company.code', name: 'Company', type: 'string' }),
            Comparators.equalTo,
            this.company.code
        ).toQueryRestriction();
        const query = {
            ...querySearch,
            queryRestrictions: [activeRestriction, companyRestriction].concat(querySearch.queryRestrictions),
        };
        return this.nonInventoryItemFacade.search(query);
    };

    onStoreSelected = (store: Described) => {
        this.model.store = store;
        const requestedStore = this.storeList.find((s) => s.code === store.code);
        this.company = requestedStore.company;
        this.storeCode = requestedStore.code;
    };

    private onStoresLoaded = (resources) => {
        this.storeList = resources.resources;
        if (this.storeList.length === 1) {
            this.form.setControlValue('store', this.storeList[0]);
        }
    };

    /**
     * Get route parameters from URL
     */
    private getRouteParams(route: ActivatedRoute): { accessMode: AccessMode; storeCode: string; orderNumber: string } {
        const params = route.snapshot.paramMap;
        const accessMode = AccessMode.of(params.get('accessMode'));
        const storeCode = params.get('storeCode');
        const orderNumber = params.get('orderNumber');
        this.queryParams = route.snapshot.queryParamMap;
        return { accessMode, storeCode: storeCode, orderNumber };
    }

    /**
     * Initialize form with current values
     */
    initializeForm(nonInventoryOrder: NonInventoryOrder): void {
        // You should not be able to edit a finalized order - just switch the access mode over to VIEW before form is created
        if (this.accessMode.isEdit && nonInventoryOrder.status.code === 'FINALIZED') {
            this.accessMode = AccessMode.VIEW;
        }
        if (isNullOrUndefined(this.form)) {
            this.form = this.formFactory.group('NonInventoryOrder', nonInventoryOrder, this._destroyed, {
                accessMode: this.accessMode,
            });
        }
        if (this.accessMode.isAdd) {
            this.form
                .getControl('store')
                .valueChanges.pipe(debounceTime(200), takeUntil(this._destroyed))
                .subscribe(this.onStoreSelected);
            this.resourceFacade
                .findStoresByRoles(['ROLE_NON_INVENTORY_ORDER_ADD'], 'ACTIVE', true)
                .subscribe(this.onStoresLoaded);
        } else if (this.accessMode.isEdit) {
            this.company = nonInventoryOrder.store.company;
            this.storeCode = nonInventoryOrder.store.code;
            this.storeList = [nonInventoryOrder.store];
            this.isLoading = false;
        } else {
            this.company = nonInventoryOrder.store.company;
            this.storeList = [nonInventoryOrder.store];
            this.form.disable();
            this.isLoading = false;
        }
    }

    addRequestedItems(products: { id: number; number: string }[]): void {
        this.isLoading = true;
        this.generateItems(
            this.form.getArray('nonInventoryOrderItems').getRawValue(),
            products.map((p) => p.number)
        );
        this.form.markAsDirty();
    }

    /**
     * Method that generates items for the non inventory order.
     *
     * If the existing items are provided, then the list of new items will be added to the existing items.
     * If new item numbers are provided, then only items for those numbers will be generated and added to the existing items.
     */
    generateItems(existingItems: NonInventoryOrderItem[] = [], newItemNumbers?: string[]): void {
        if (newItemNumbers.length === 1) {
            newItemNumbers = newItemNumbers.map((i) => i.split(',').map((j) => j.trim()))[0];
        }
        this.nonInventoryItemFacade
            .getItemDetails(this.company.code, this.storeCode, newItemNumbers)
            .pipe(
                map((newItems: NonInventoryCatalog[]) => {
                    const newItemsToAdd = newItems.map((n) => n.number);

                    const duplicatedItems = newItemsToAdd.filter((i) =>
                        this.existingItemNumbers.map((ei) => ei.toUpperCase()).includes(i.toUpperCase())
                    );

                    if (duplicatedItems.length > 0) {
                        this.messageFacade.addMessage({
                            severity: 'error',
                            message: `Item(s) ${duplicatedItems.join(', ')} already added.`,
                            hasTimeout: true,
                        });
                        // remove the duplicate items from the products to be added
                        duplicatedItems.forEach((di) => (newItems = newItems.filter((n) => n.number !== di)));
                    }

                    // Show error message if the requested item wasn't found
                    const missingNumbers = newItemNumbers.filter((n) => !newItemsToAdd.includes(n));

                    if (missingNumbers.length > 0) {
                        this.messageFacade.addMessage({
                            severity: 'error',
                            message: `Unable to add requested item(s): ${missingNumbers.join(', ')}.`,
                            hasTimeout: true,
                        });
                    }
                    return newItems;
                }),
                map((newItems) => {
                    if (newItems.length !== 0) {
                        const itemToNewItem = newItems.map((np) => this.mapGeneratedItemToNewItem(np));
                        this.addItemsToForm(existingItems, itemToNewItem);
                    }
                    return this.initializeTable();
                }),
                tap(() => {
                    this.isLoading = false;
                    this.isGeneratingOrder = true;
                }),
                catchError((e) => {
                    // No longer generating order but rethrow any error
                    this.isLoading = false;
                    this.isGeneratingOrder = false;
                    return throwError(e);
                })
            )
            .subscribe();
    }

    /** Convert a newly generated non inventory order item response to a NonInventoryOrderItem */
    private mapGeneratedItemToNewItem(inventoryDetail: any): NonInventoryOrderItem {
        // Overlaying each product response on a blank NonInventoryOrderItem to make sure all fields are initialized (including ones not included in the response)
        return {
            ...new NonInventoryOrderItem(),
            uom: inventoryDetail.uom,
            nonInventoryCatalog: {
                id: inventoryDetail.id,
                number: inventoryDetail.number,
                description: inventoryDetail.description,
                minimumQuantity: inventoryDetail.minimumQuantity,
                maximumQuantity: inventoryDetail.maximumQuantity,
                quantityPerPack: inventoryDetail.quantityPerPack,
            },
            quantity: inventoryDetail.suggestedQuantity === 0 ? null : inventoryDetail.suggestedQuantity,
        };
    }

    private addItemsToForm(existingProducts: NonInventoryOrderItem[], newProducts: NonInventoryOrderItem[]): void {
        const validator = this.form.getControl('nonInventoryOrderItems').validator;
        // create form array for items using generated items
        this.form.setControl(
            'nonInventoryOrderItems',
            this.formFactory.array(
                'NonInventoryOrderItem',
                // Appending newly added items to the existing items
                existingProducts.concat(newProducts),
                this._destroyed,
                { accessMode: this.accessMode }
            )
        );
        // Copy existing validation into new control
        this.form.getControl('nonInventoryOrderItems').setValidators(validator);
        // Run validation in case the new control is empty
        this.form.getControl('nonInventoryOrderItems').updateValueAndValidity();
        this.nonInventoryOrderItems.markAsDirty();
    }

    /** Determines if all of the available rows of the table are selected. */
    isAllSelected(data: TypedFormGroup<NonInventoryOrderItem>[]): boolean {
        const numSelected = this.selection && this.selection.selected.length;
        const numRows = data.length;
        return numSelected === numRows;
    }

    /** If no rows are selected selects all available rows, if all rows are selected then clears the selection. */
    masterToggle(data: TypedFormGroup<NonInventoryOrderItem>[]): void {
        this.isAllSelected(data) ? this.selection.clear() : data.forEach((row) => this.selection.select(row));
    }

    /** Remove items based on selectionModel */
    removeItems(): void {
        if (this.selection.selected.length > 0) {
            this.isGeneratingOrder = false;
        } else {
            this.isGeneratingOrder = true;
        }
        // iterate over selected items to determine which are to be deleted
        this.selection.selected.forEach((productFormGroup) => {
            // find index of currently selected item in model
            const index = this.nonInventoryOrderItems.controls.findIndex(
                (orderProduct) =>
                    orderProduct.value.nonInventoryCatalog.id === productFormGroup.value.nonInventoryCatalog.id
            );
            // remove selected currently item from model at index
            this.nonInventoryOrderItems.removeAt(index);
        });
        // rebuild table from updated item clear selections
        this.initializeTable();
        this.nonInventoryOrderItems.markAsDirty();
        this.table.renderRows();
        this.selection.clear();
    }

    /** Initialize table data source with given products and sorting */
    initializeTable() {
        this.items = new MatTableDataSource<TypedFormGroup<NonInventoryOrderItem>>(
            this.nonInventoryOrderItems.controls as TypedFormGroup<NonInventoryOrderItem>[]
        );
        // for columns with nested properties
        this.items.sortingDataAccessor = (item, property) => {
            switch (property) {
                case 'nonInventoryCatalog.number':
                    return item.getControlValue('nonInventoryCatalog').number;
                case 'nonInventoryCatalog.description':
                    return item.getControlValue('nonInventoryCatalog').description;
                case 'nonInventoryCatalog.minimumQuantity':
                    return item.getControlValue('nonInventoryCatalog').minimumQuantity;
                case 'nonInventoryCatalog.maximumQuantity':
                    return item.getControlValue('nonInventoryCatalog').maximumQuantity;
                case 'nonInventoryCatalog.quantityPerPack':
                    return item.getControlValue('nonInventoryCatalog').quantityPerPack;
                case 'uom':
                    return item.getControlValue('uom').description;
                default:
                    return item.get(property).value;
            }
        };
    }

    get nonInventoryOrderItems(): FormArray {
        return this.form.getArray('nonInventoryOrderItems');
    }
    get storesSelected(): boolean {
        return !isNullOrUndefined(this.form.getControlValue('store'));
    }

    get orderNumber(): number {
        return this.model.id?.orderNumber;
    }

    get isStoreEditable(): boolean {
        return this.accessMode.isAdd && !this.isGeneratingOrder;
    }

    get renderSelection(): boolean {
        return this.accessMode.isAdd || (this.accessMode.isEdit && this.model.status.code === 'OPEN');
    }

    quantity(rowIndex: number) {
        return this.form.get('nonInventoryOrderItems').get(`${rowIndex}`).get('quantity');
    }

    /** Save and navigate back to previous page. */
    save(): void {
        this.saveFacade.save(this.form, this.model, this.route).subscribe();
    }

    apply(): void {
        const reload = () => {};
        this.saveFacade.apply(this.form, this.model, reload).subscribe((id: NonInventoryOrderPK) => {
            if (this.accessMode.isAdd) {
                // update the id for save message
                this.model.id = id;
                this.router.navigate(
                    [AccessMode.EDIT.urlSegement, this.form.getControlValue('store').code, id.orderNumber],
                    { relativeTo: this.route.parent }
                );
            } else {
                this.form = undefined;
                this.ngOnInit();
            }
        });
    }

    get itemsEditable(): boolean {
        return this.accessMode.isAdd || this.accessMode.isEdit;
    }

    openFinalizeOrderDialog(): void {
        this.finalizeDialog.open();
    }

    closeFinalizeDialog(): void {
        this.finalizeDialog.close();
    }

    finalize(): void {
        this.closeFinalizeDialog();
        this.finalizeFacade.save(this.form, this.model, this.route).subscribe();
    }

    get orderIsFinalized(): boolean {
        return this.form.getControlValue('status')?.code === 'FINALIZED';
    }

    get existingItemNumbers(): string[] {
        return this.form.getArrayValue('nonInventoryOrderItems').map((iop) => iop.nonInventoryCatalog.number);
    }

    ngOnDestroy(): void {
        this._destroyed.next();
    }

    /** @see DataModifyingComponent */
    get unsavedChanges(): boolean {
        return this.form && this.form.dirty;
    }
}
